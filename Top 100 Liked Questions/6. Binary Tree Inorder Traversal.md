# 94. Binary Tree Inorder Traversal

Given the root of a binary tree, return the inorder traversal of its nodes' values.

# Example 1:
![inorder_1](https://user-images.githubusercontent.com/72177954/133171933-fd8e4b29-3945-490f-8188-238e76dff630.jpg)
```
Input: root = [1,null,2,3]
Output: [1,3,2]
```
# Example 2:
```
Input: root = []
Output: []
```
# Example 3:
```
Input: root = [1]
Output: [1]
```
# Example 4:
![inorder_5](https://user-images.githubusercontent.com/72177954/133171953-1a968cbf-cb06-4f92-ab7c-c66bcb662428.jpg)
```
Input: root = [1,2]
Output: [2,1]
```
# Example 5:
![inorder_4](https://user-images.githubusercontent.com/72177954/133171974-f19e65ab-f28e-499a-8a23-d6b0717d1563.jpg)
```
Input: root = [1,null,2]
Output: [1,2]
```
# Constraints:
- The number of nodes in the tree is in the range [0, 100].
- `-100 <= Node.val <= 100`

**Follow up**: Recursive solution is trivial, could you do it iteratively?

# My wrong approach 
- I was getting empty list as output for all input test case
- First lets understand input, It is dictionary for 3 values and nested dictionary for more than 3 values, it can be understand through this code:
```
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode], traversalList = []) -> List[int]:
    
        while(root!=None):
            print(root)
            root=root.left
        return traversalList
```
- INPUT: `[1,null,2,3]`
- OUTPUT: `TreeNode{val: 1, left: None, right: TreeNode{val: 2, left: TreeNode{val: 3, left: None, right: None}, right: None}}`
- So what is happening for above input in my code is: in the first if condition itself my program is ending, since `root.left==None` is true and it returns traversalList before even appending happens according to priority order.
- Even if we give input as `[1,2,3,4]` we will get an error first of all since we didnt write `self.inorderTraversal` even if we correct that, we will get null type error as, inside the if condition we are using `traversalList.append(root.val)` which returns an empty list since it returns list first before appending. Even if we correct it, we will now get wrong ans. The input is actually a nested dictionary : `TreeNode{val: 1, left: TreeNode{val: 2, left: TreeNode{val: 4, left: None, right: None}, right: None}, right: TreeNode{val: 3, left: None, right: None}} TreeNode{val: 2, left: TreeNode{val: 4, left: None, right: None}, right: None} TreeNode{val: 4, left: None, right: None}`. So what will happen is first 2 will be added to the list then concatenation will happen list.concat(list) now list = [2,2]. Then flow of control will come out of recursive call stack and now go to `traversalList.extend(self.inorderTraversal(root.right,traversalList())` and then first condition (root.left==None) will true so list will be updated to list = [2,2,3] now after return list will concatenate with itself again. hence list will be updated to list = [2,2,3,2,2,3] which is wrong ans.
```
class Solution:
    
    def inorderTraversal(self, root: Optional[TreeNode], traversalList = []) -> List[int]:
        if root.left==None:
            return traversalList.append(root.val)
        if root.right == None :
            return traversalList.append(root.val)
        traversalList.extend(inorderTraversal(root.left,traversalList))
        traversalList.extend(inorderTraversal(root.right,traversalList))
        return traversalList
```
# What did I learn ?
- Inorder Tree traversal
- standard program for recursive inorder tree traversal
- NoneType attribute error
- difference between class variable inside constructor Vs outside constructor but inside class
- while finding error in my code, I need to print stuff to see how the flow of control is going, and also realised that input was nested dictionary (obj of class TreeNode) with value, left and right as its key. Instead of list.
- I learned that while returning list.append(value), first list is returned occurs and value isnt even appended. So an empty list is returned and it throws an error after it comes out of recursive call stack.
- Addition of values to list shouldnt be inside if conditions.
- dont forget to write self wherever necessary.

# Forum correct approach
### Recursive approach
- We first define a constructor inside Solution class so that everytime an obj of class Solution is created a new ans list is created with it or else everytime new obj of class Solution is created the same ans list will be used everytime and inorder traversal of all the input test case will stored in one ans list and only first test case will be correct all the other test cases following it will have inorder traversal values of all the testcases before it.
- Now inside inorderTraversal we first write the base case of recursion, if root is None or not or is the list element in cosideration is None or not. If yes we return to the pervious iteration of recursive stack and append the element/value to ans list. Likewise we now do it for `root.right` attribute. These recursion continue until we reach end of right most node of Tree.
```
class Solution:
    def __init__(self):
        self.ans=[]
        
    def inorderTraversal(self, root: Optional[TreeNode],) -> List[int]:
        if root is None:
            return
        self.inorderTraversal(root.left)
        self.ans.append(root.val)
        self.inorderTraversal(root.right)
    
        return self.ans
```
# Forum Iterative Approach
- This approach is a little harder to think of, but I believe once we get a hang of it. It will become intuitive.
- So basically we need a stack (list implementation of stack) and list for this algo.
- we keep iterating over root and its left node, and replace root with its left node at the end of each iteration, till we reach a None (null) root node.
- so what we are doing is going to the left most node while going through all the left node possible in each case and adding it to the stack.
- after we reach null node, we go one step behind by `root=stack.pop()` which hold the revious not null node. then we add its value to ans array since its the left most node of the tree.
- after adding value to ans list, we now go the right node of this node and check if its null, if its not null then again we will keep on checking of more left most node in this subtree.
- if it is null, then we again make the root to previous non null root node and repeat the cycle.
```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
        
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans = []
        S = []
        while(root or S):
            if root:
                S.append(root)
                root = root.left
            else:
                root = S.pop()
                ans.append(root.val)
                root = root.right
        return ans
```
# Reference
- https://stackoverflow.com/questions/8949252/why-do-i-get-attributeerror-nonetype-object-has-no-attribute-something
- https://stackoverflow.com/questions/2878499/python-oop-and-lists
- https://leetcode.com/problems/binary-tree-inorder-traversal/discuss/1460392/Python3-Simple-and-readable
- https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/
- https://jianlu.github.io/2014/04/04/leetcode94-Binary-Tree-Inorder-Traversal/
