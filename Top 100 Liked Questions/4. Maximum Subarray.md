# 53. Maximum Subarray
Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

A subarray is a contiguous part of an array.

# Example 1:
* Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
* Output: 6
* Explanation: [4,-1,2,1] has the largest sum = 6.

# Example 2:
* Input: nums = [1]
* Output: 1

# Example 3:
* Input: nums = [5,4,-1,7,8]
* Output: 23
 
# Constraints:
* 1 <= nums.length <= 3 * 104
* -105 <= nums[i] <= 105
 
### Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.

# My wrong approach
```
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        sum1=sum(nums)
        k=0
        m=1
        max1=sum1
        while(1):
            print("sum : ",sum1)
            if (sum1-nums[len(nums)-m])>sum1:
                sum1=sum1-nums[len(nums)-m]
                m=m+1
            elif (sum1-nums[k])>sum1:
                sum1=sum1-nums[k]
                k=k+1
            if sum1>max1:
                max1=sum1
        return max1
```

# What did I miss ?
* my approach was completely wrong i was getting runtime error, because I couldnt think of the exit condition for my while loop
* Correct solution is used bottom up DP approach was I havent worked much with, only have seen it once or twice in video
* sums(ListName) is an inbuilt function that I have to remember, cant keep googling before every problem 

# Forum Correct Approach - O(n)
The intuition is the quickest one should be O(N). The reason is at least I need to visit each element once. Let me imaging when I run into a number with index = x, the largest sum of a subarray ending with x should be a largest sum of “prefix” subarray ending with x-1 plus the number at x. It can be a little hard to understand so let me use an example: assuming in [-2,1,-3,4,-1,2,1, -5,4], now I’m looking to find a subarray that ends with index=2 (number is -3) and having the largest sum.

There will be 2 “prefix” candidates: [-2,1], [1], they can join with -3 to make 2 candidates [-2,1,-3] and [1,-3]; also, there is possible neglectable point, I can use NONE of “prefix” and just use current number to make a subarray, so there is another candidate which is [-3]. Out of [-2,1,-3], [1,-3], [-3], who will be the one with largest sum? It will be [1,-3] while the prefix is [1] which has the largest sum of all subarrays ending with index=1 (nubmer is 1).

So this is actually a dynamic programming problem. If dp[i] represents the largest sum of all subarrays ending with index i, then its value should be the larger one between nums[i] (without using prefix) and dp[i-1] + nums[i] (using prefix with largest sum plus current number):

```
dp[i] = max(dp[i-1] + nums[i], nums[i])
# to start with, dp[0] = nums[0]
```

So I just need to calculate dp[0], dp[1]…, dp[n] while comparing each one with current largest sum, if dp[i] > current_largest_sum then current_largest_sum = dp[i].
```
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        dp = []
        dp.append(nums[0])
        current_largest_sum = dp[0]
        for i in range(1, len(nums)):
            dp.append(max(dp[i-1] + nums[i], nums[i]))
            if dp[i] > current_largest_sum:
                current_largest_sum = dp[i]
        return current_largest_sum
```
### Time & Space Complexity
For time complexity, the best solution is O(N) since it only visits each element of input array for once. Space complexity is also O(N) since there is an auxiliary array (dp) is used. This can be optimized since essentially, when calculating dp[i], I only need dp[i-1] and not the rest (like dp[i-2], dp[i-3]…). So I can reduce space complexity to O(1) by dropping the array (dp) and just use a variable to keep last value (which is dp[i-1]).

# References :
* https://medium.com/tech-life-fun/leet-code-53-maximum-subarray-detailed-explained-python3-solution-d91c7affc02a
