# 1. Two Sum ([link](https://leetcode.com/problems/two-sum/))

Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.

# Example 1:
```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Output: Because nums[0] + nums[1] == 9, we return [0, 1].
```
# Example 2:
```
Input: nums = [3,2,4], target = 6
Output: [1,2]
```
# Example 3:
```
Input: nums = [3,3], target = 6
Output: [0,1]
``` 

# Constraints:

* ` 2 <= nums.length <= 104 `
* ` -109 <= nums[i] <= 109 `
* ` -109 <= target <= 109 `
* **Only one valid answer exists.**

Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity?

# O(n^2) approach 

loop over the list with two for loop, outer loop from i = 1st element to i = 2nd last element and inner loop from j = (i+1) element to j = last element, and compare if nums[i]+nums[j] == target in each iteration, if true return [i,j]

Code :

```
class Solution:
    def twoSum(self, nums: List[int], target: int):
        for i in range(len(nums)-1):
            for j in range(i+1,len(nums)):
                if nums[i]+nums[j]==target:
                    return [i,j]
```

# What did I miss ?

* For Leetcode submissions we need to write code inside a class.
* I was trying to iterate both outer and inner loop from 1st element to last element, by which I was repeating comparisons. This is unnecessary, instead we had to loop outer loop from 1st to 2nd last element and inner loop from (inner loop)+1 element to last element.
* I was trying to add range(nums) directly in for loop code, which is syntactically wrong. Instead, I should use range(len(nums)).
* len(nums) gives number of elements in the list.
* range(len(nums)) iterate over from 0th index to (n-1) index or last index of list.

# O(n) approach 

* ` Define one map(dictionary) called required to hold the elements of nums list(array) which are already compared `
* ` For index i in range 0 to n – 1 (where n is the number of elements in the list(array)) `
    * ` if target − nums[i] is present in required(dictionary) `
        * ` return required[target − nums[i]] and i as indices `
    * ` Otherwise put i into the required(dictionary) as required[A[i]] = i `

So basically what we are trying do here is creating a dictionary '**required**' which has a key as elements of nums and value as it's index in nums. We know that nums[i]+nums[some index]=target for one unique pair of elements (given in question) so : </br></br>
` nums[i] + nums[some index] = target `</br>
` => nums[some index] = target - nums[i] ` </br></br>
We are trying to search if `target - nums[i]` is present in required dictionary or not, if it isnt a part of required dictionary. We store nums[i] that we just compared (`if target-nums[i] in required`) in required dictionary as `{ 'num[i]' : i, ... }`. Since the dictionary is empty, the first element of nums list will always be added to the dictionary. Now while comparing from the 2nd element of nums list onwards if `target-nums[i]` is in required dictionary that means we found a pair for which sum of two elements of nums list is equal to target. Now we can return the two index of the pair by returning one from dictionary ( required[target-nums[i]] ) and one from nums list ( i ).
```
class Solution(object):
   def twoSum(self, nums, target):
      required = {}
      for i in range(len(nums)):
         if target - nums[i] in required:
            return [required[target - nums[i]],i]
         else:
            required[nums[i]]=i
```

# What did I miss ?

* Not used to using maps, so the thought that map can be used in such a way did not came up in mind. So I have made a report on map to help myself get familiar with it. It will be at the bottom of this document.
* In the algo, we are creating a copy of nums list elements on each iteration by putting pair of element and it's index in a dictionary. While iterating if we do get a pair of nums list elements for which their sum is target, we can return their address one from dictionary values and one from iteration count.

# Report on MAPS

### 1. First let's understand IMMUTABLE : 
An object with a fixed value. Immutable objects include numbers, strings and tuples. Such an object cannot be altered. A new object has to be created if a different value has to be stored. They play an important role in places where a constant hash value is needed, for example as a key in a dictionary.

### 2. Now let's understand HASHABLE :
An object is hashable if it has a hash value which never changes during its lifetime, and can be compared to other objects. Hashable objects which compare equal must have the same hash value.

Hashability makes an object usable as a dictionary key and a set member, because these data structures use the hash value internally.

Most of Python’s immutable built-in objects are hashable; mutable containers (such as lists or dictionaries) are not; immutable containers (such as tuples and frozensets) are only hashable if their elements are hashable. Objects which are instances of user-defined classes are hashable by default. They all compare unequal (except with themselves), and their hash value is derived from their id().

### 3. Finally lets learn about a mapping type called Dictionary

A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in list, set, and tuple classes, and the collections module.)

A dictionary’s keys are almost arbitrary values. Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (such as 1 and 1.0) then they can be used interchangeably to index the same dictionary entry. (Note however, that since computers store floating-point numbers as approximations it is usually unwise to use them as dictionary keys.)

Dictionaries can be created by placing a comma-separated list of key: value pairs within braces, for example: `{'jack': 4098, 'sjoerd': 4127} or {4098: 'jack', 4127: 'sjoerd'}`, or by the dict constructor.

* class dict(**kwarg)
* class dict(mapping, **kwarg)
* class dict(iterable, **kwarg)</br>
Return a new dictionary initialized from an optional positional argument and a possibly empty set of keyword arguments.

Dictionaries can be created by several means:

* Use a comma-separated list of key: value pairs within braces: `{'jack': 4098, 'sjoerd': 4127} or {4098: 'jack', 4127: 'sjoerd'}`
* Use a dict comprehension: `{}, {x: x ** 2 for x in range(10)}`
* Use the type constructor: dict(), `dict([('foo', 100), ('bar', 200)]), dict(foo=100, bar=200)`

For information on how to operate and use dictionaries : https://www.geeksforgeeks.org/python-dictionary/

# Reference 

* https://www.tutorialspoint.com/two-sum-in-python
* https://docs.python.org/3/tutorial/datastructures.html
* https://docs.python.org/3/library/stdtypes.html#typesmapping
* https://docs.python.org/3/glossary.html#term-hashable
* [https://docs.python.org/3/reference/datamodel.html#object.__hash__](https://docs.python.org/3/reference/datamodel.html#object.__hash__)
