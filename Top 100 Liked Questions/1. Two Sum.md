# 1. Two Sum ([link](https://leetcode.com/problems/two-sum/))

Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.

# Example 1:
```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Output: Because nums[0] + nums[1] == 9, we return [0, 1].
```
# Example 2:
```
Input: nums = [3,2,4], target = 6
Output: [1,2]
```
# Example 3:
```
Input: nums = [3,3], target = 6
Output: [0,1]
``` 

# Constraints:

* ` 2 <= nums.length <= 104 `
* ` -109 <= nums[i] <= 109 `
* ` -109 <= target <= 109 `
* **Only one valid answer exists.**

Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity?

# O(n^2) approach 

loop over the list with two for loop, outer loop from i = 1st element to i = 2nd last element and inner loop from j = (i+1) element to j = last element, and compare if nums[i]+nums[j] == target in each iteration, if true return [i,j]

Code :

```
class Solution:
    def twoSum(self, nums: List[int], target: int):
        for i in range(len(nums)-1):
            for j in range(i+1,len(nums)):
                if nums[i]+nums[j]==target:
                    return [i,j]
```

# What did I miss ?

* For Leetcode submissions we need to write code inside a class.
* I was trying to iterate both outer and inner loop from 1st element to last element, by which I was repeating comparisons. This is unnecessary, instead we had to loop outer loop from 1st to 2nd last element and inner loop from (inner loop)+1 element to last element.
* I was trying to add range(nums) directly in for loop code, which is syntactically wrong. Instead, I should use range(len(nums)).
* len(nums) gives number of elements in the list.
* range(len(nums)) iterate over from 0th index to (n-1) index or last index of list.

# O(n) approach 

```
class Solution(object):
   def twoSum(self, nums, target):
      """
      :type nums: List[int]
      :type target: int
      :rtype: List[int]
      """
      required = {}
      for i in range(len(nums)):
         if target - nums[i] in required:
            return [required[target - nums[i]],i]
         else:
            required[nums[i]]=i
```

# What did I miss ?

* Not used to using maps, so the thought that map can be used in such a did not came up in mind. So I have made a report on map to help myself get familiar with it. It will be at the bottom of this document.
